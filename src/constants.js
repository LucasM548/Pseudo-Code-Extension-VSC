"use strict";
/**
 * Configuration centralisée pour l'extension Pseudo-Code
 * Tous les patterns regex et mots-clés sont définis ici pour éviter la duplication
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LUA_HELPERS = exports.FUNCTION_MAPPING = exports.LUA_REPLACEMENTS = exports.TYPE_MAPPING = exports.PATTERNS = exports.KNOWN_IDENTIFIERS = exports.BUILTIN_FUNCTION_ARITY = exports.KEYWORDS = void 0;
var definitions_1 = require("./definitions");
// Mots-clés du langage
exports.KEYWORDS = {
    CONTROL: definitions_1.PSC_DEFINITIONS.keywords.filter(function (k) { return k.type === 'control'; }).map(function (k) { return k.name; }),
    BLOCKS: definitions_1.PSC_DEFINITIONS.keywords.filter(function (k) { return k.type === 'block'; }).map(function (k) { return k.name; }),
    TYPES: definitions_1.PSC_DEFINITIONS.types.flatMap(function (t) { return t.aliases; }),
    BOOLEAN: definitions_1.PSC_DEFINITIONS.keywords.filter(function (k) { return k.type === 'boolean'; }).map(function (k) { return k.name; }),
    OPERATORS: definitions_1.PSC_DEFINITIONS.keywords.filter(function (k) { return k.type === 'operator'; }).map(function (k) { return k.name; }),
    IO: definitions_1.PSC_DEFINITIONS.keywords.filter(function (k) { return k.type === 'io'; }).map(function (k) { return k.name; }),
    MODIFIERS: definitions_1.PSC_DEFINITIONS.keywords.filter(function (k) { return k.type === 'modifier'; }).map(function (k) { return k.name; }),
    // Fonctions spéciales avec traitement particulier dans l'executor
    STRING_OPS: ['longueur', 'concat', 'souschaîne', 'ième'],
    // TOUTES les fonctions sont maintenant automatiquement extraites de definitions.ts
    ALL_FUNCTIONS: definitions_1.PSC_DEFINITIONS.functions.map(function (f) { return f.name; })
};
// Arité attendue des fonctions intégrées (pour le linter)
// Clés en minuscules (comparaison insensible à la casse côté linter)
exports.BUILTIN_FUNCTION_ARITY = Object.fromEntries(definitions_1.PSC_DEFINITIONS.functions.map(function (f) { return [f.name, f.arity]; }));
// Tous les identifiants connus (pour le linter)
// ✨ AUTOMATIQUE : Toute fonction ajoutée dans definitions.ts sera automatiquement reconnue
exports.KNOWN_IDENTIFIERS = new Set(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], exports.KEYWORDS.CONTROL, true), exports.KEYWORDS.BLOCKS, true), exports.KEYWORDS.TYPES, true), exports.KEYWORDS.BOOLEAN, true), exports.KEYWORDS.OPERATORS, true), exports.KEYWORDS.IO, true), exports.KEYWORDS.MODIFIERS, true), exports.KEYWORDS.STRING_OPS, true), exports.KEYWORDS.ALL_FUNCTIONS, true), [
    'lexique', 'fin_ligne'
], false));
// Patterns regex réutilisables
exports.PATTERNS = {
    // Identifiants
    IDENTIFIER: /[\p{L}_][\p{L}0-9_]*/u,
    IDENTIFIER_GLOBAL: /[\p{L}_][\p{L}0-9_]*/gu,
    WORD_BOUNDARY_IDENTIFIER: /(?<![\p{L}0-9_])[\p{L}_][\p{L}0-9_]*(?![\p{L}0-9_])/gu,
    // Fonction
    FUNCTION_DECLARATION: /^\s*Fonction\s+([\p{L}_][\p{L}0-9_]*)\s*\((.*)\)/iu,
    FUNCTION_CALL: /([\p{L}_][\p{L}0-9_]+)\s*\(([^)]*)\)/gu,
    // Variables
    VARIABLE_DECLARATION: /^([\p{L}0-9_,\s]+?)\s*:\s*([\p{L}0-9_]+(?:\([^()]*\))?)/iu,
    ASSIGNMENT: /←/,
    READ_ASSIGNMENT: /^\s*[\p{L}0-9_]+\s*←\s*lire\s*\(\s*\)\s*$/iu,
    // Types composites
    COMPOSITE_TYPE: /^([\p{L}_][\p{L}0-9_]*)\s*(?:=\s*)?<\s*(.+?)\s*>$/iu,
    COMPOSITE_FIELD: /^([\p{L}_][\p{L}0-9_]*)\s*:\s*(.+)$/iu,
    COMPOSITE_LITERAL: /(?<![\w\s])<([^>]+)>/g,
    // Tableaux
    ARRAY_LITERAL: /(?<![\p{L}0-9_])\[([^\]]*)\]/gu,
    ARRAY_ACCESS: /([\p{L}0-9_]+)\[([^\]]+)\]/gu,
    // Structures de contrôle
    FOR_LOOP: /^\s*Pour\s+([\p{L}0-9_]+)\s+(?:allant de|de)\s+(.+)\s+(?:a|à)\s+(.+)\s+Faire\s*:?/iu,
    WHILE_LOOP: /^\s*Tant que\b/i,
    IF_STATEMENT: /^\s*Si\b/i,
    ELSE_IF: /^\s*Sinon\s+si\b/i,
    ELSE: /^\s*Sinon\b/i,
    // Blocs
    ALGORITHM: /^\s*algorithme\b/i,
    BEGIN: /^\s*Début\b/i,
    END: /^\s*Fin\b/i,
    CLOSING_KEYWORDS: /^\s*(Fin|fsi|fpour|ftq|ftant)\b/i,
    OPENING_BLOCK: /^\s*(Si|Tant que|Début)(?![\p{L}0-9_])/iu,
    // Commentaires
    LINE_COMMENT: /\/\/.*/,
    BLOCK_COMMENT: /\/\*[\s\S]*?\*\//g,
    LEXIQUE: /Lexique\s*:?[\s\S]*/i,
    // Strings
    DOUBLE_QUOTES: /"[^"]*"/g,
    SINGLE_QUOTES: /'(?:\\.|[^\\'])'/g,
    SMART_QUOTES: /[""]/g,
    // Accès aux champs d'objets
    FIELD_ACCESS: /([\p{L}_][\p{L}0-9_]*)\.([\p{L}_][\p{L}0-9_]*)/gu,
    BRACKET_FIELD_ACCESS: /(\])\.([\p{L}_][\p{L}0-9_]*)/gu,
    DOT_FIELD: /\.[\p{L}_][\p{L}0-9_]*/gu
};
// Mapping des types normalisés
exports.TYPE_MAPPING = Object.fromEntries(definitions_1.PSC_DEFINITIONS.types.flatMap(function (t) { return t.aliases.map(function (alias) { return [alias, t.name]; }); }));
// Remplacements de symboles pour Lua
exports.LUA_REPLACEMENTS = __assign(__assign({}, Object.fromEntries(definitions_1.PSC_DEFINITIONS.keywords
    .filter(function (k) { return k.luaEquivalent; })
    .map(function (k) { return [k.name, k.luaEquivalent]; }))), { 
    // Opérateurs arithmétiques et spéciaux non couverts par les mots-clés simples
    '≠': '~=', '≤': '<=', '≥': '>=', '÷': '//', 'lire()': '__psc_lire()', 'FIN_LIGNE': "'\n'" });
// Fonctions PSC mappées vers des helpers Lua
exports.FUNCTION_MAPPING = Object.fromEntries(definitions_1.PSC_DEFINITIONS.functions.map(function (f) { return [f.name, f.luaHelper]; }));
// Helpers Lua
exports.LUA_HELPERS = "if package.config:sub(1,1) == \"\\\\\" then os.execute(\"chcp 65001 >nul\") end\nlocal __psc_file_handles = {}\nlocal __psc_file_current_handle = 1\n\nlocal function __psc_fichierCreer(nomFichier)\n    return __psc_fichierOuvrir(nomFichier, \"w\")\nend\n\nlocal function __psc_fichierEcrire(handle, value)\n    if __psc_file_handles[handle] then\n        __psc_file_handles[handle]:write(tostring(value))\n    end\nend\n\nlocal function __psc_fichierOuvrir(nomFichier, mode)\n    mode = mode or \"r\"\n    local file, err = io.open(nomFichier, mode)\n    if not file then\n        print(\"Erreur d'ouverture du fichier: \" .. tostring(err))\n        return nil\n    end\n    local handle = __psc_file_current_handle\n    __psc_file_handles[handle] = file\n    __psc_file_current_handle = __psc_file_current_handle + 1\n    return handle\nend\n\nlocal function __psc_fichierFermer(handle)\n    if __psc_file_handles[handle] then\n        __psc_file_handles[handle]:close()\n        __psc_file_handles[handle] = nil\n    end\nend\n\nlocal function __psc_fichierLire(handle)\n    if __psc_file_handles[handle] then\n        return __psc_file_handles[handle]:read()\n    end\n    return nil\nend\n\nlocal function __psc_fichierFin(handle)\n    if __psc_file_handles[handle] then\n        local pos = __psc_file_handles[handle]:seek()\n        local _, err = __psc_file_handles[handle]:read(0)\n        __psc_file_handles[handle]:seek(\"set\", pos)\n        return err == \"end of file\"\n    end\n    return true\nend\n\nlocal function __psc_chaineVersEntier(chaine)\n    return tonumber(chaine) or 0\nend\n\n-- Fonction de lecture personnalis\u00E9e qui convertit automatiquement en nombre si possible\nlocal function __psc_lire()\n    local input = io.read()\n    if input then\n        local num = tonumber(input)\n        if num then\n            return num\n        end\n    end\n    return input\nend\n\n\nlocal function __psc_is_array(t)\n    if type(t) ~= 'table' then return false end\n    local i = 0\n    for _ in pairs(t) do\n        i = i + 1\n    end\n    local count = 0\n    for k in pairs(t) do\n        if type(k) == 'number' then count = count + 1 end\n    end\n    return count == i\nend\n\n-- D\u00E9tection d'une liste cha\u00EEn\u00E9e TDA (n\u0153ud avec champs 'val' et/ou 'suc')\nlocal function __psc_is_liste(t)\n    return type(t) == 'table' and (t.val ~= nil or t.suc ~= nil)\nend\n\n-- D\u00E9tection d'une liste sym\u00E9trique TDA (table avec head/tail ou noeud avec val/suc/prec)\nlocal function __psc_is_listesym(t)\n    -- Structure conteneur { head = ..., tail = ... }\n    if type(t) == 'table' and (t.head ~= nil or t.tail ~= nil) then return true end\n    -- Noeud { val=..., suc=..., prec=... }\n    if type(t) == 'table' and (t.val ~= nil and (t.suc ~= nil or t.prec ~= nil)) then return true end\n    return false\nend\n\n-- S\u00E9rialisation g\u00E9n\u00E9rique (incluant listes TDA au format (a, b, c))\nlocal function __psc_serialize(v)\n    -- Gestion des valeurs nil (listes vides)\n    if v == nil then\n        return '()'\n    end\n    \n    if type(v) == 'table' then\n        -- V\u00E9rifier d'abord si c'est une Pile ou File (avec m\u00E9tadonn\u00E9e _type)\n        if v._type == 'pile' then\n            local parts = {}\n            for i = 1, #v do\n                parts[#parts+1] = __psc_serialize(v[i])\n            end\n            return 'Pile[' .. table.concat(parts, ', ') .. ']'\n        elseif v._type == 'file' then\n            local parts = {}\n            for i = 1, #v do\n                parts[#parts+1] = __psc_serialize(v[i])\n            end\n            return 'File[' .. table.concat(parts, ', ') .. ']'\n        elseif v._type == 'table' then\n            -- Table (dictionnaire/map)\n            local parts = {}\n            if v._data then\n                for k, val in pairs(v._data) do\n                    parts[#parts+1] = tostring(k) .. ':' .. __psc_serialize(val)\n                end\n            end\n            return 'Table{' .. table.concat(parts, ', ') .. '}'\n        elseif __psc_is_liste(v) then\n            local parts = {}\n            local node = v\n            while node ~= nil do\n                parts[#parts+1] = __psc_serialize(node.val)\n                node = node.suc\n            end\n            return '(' .. table.concat(parts, ', ') .. ')'\n        elseif __psc_is_listesym(v) then\n            -- Si c'est le conteneur {head=..., tail=...}\n            if v.head ~= nil or v.tail ~= nil then\n                local parts = {}\n                local node = v.head\n                while node ~= nil do\n                    parts[#parts+1] = __psc_serialize(node.val)\n                    node = node.suc\n                end\n                return 'LS(' .. table.concat(parts, ', ') .. ')'\n            end\n            -- Si c'est un noeud isol\u00E9, on l'affiche simplement\n            return '{val=' .. tostring(v.val) .. '}'\n        elseif __psc_is_array(v) then\n            -- Tableau normal\n            local parts = {}\n            for i = 1, #v do\n                parts[#parts+1] = __psc_serialize(v[i])\n            end\n            return '[' .. table.concat(parts, ', ') .. ']'\n        else\n            -- Objet/enregistrement g\u00E9n\u00E9rique (filtrer _type et _data internes)\n            local parts = {}\n            for k, val in pairs(v) do\n                if k ~= '_type' and k ~= '_data' then\n                    parts[#parts+1] = tostring(k) .. ':' .. __psc_serialize(val)\n                end\n            end\n            return '{' .. table.concat(parts, ', ') .. '}'\n        end\n    elseif type(v) == 'string' then\n        return v\n    elseif type(v) == 'boolean' then\n        return v and 'Vrai' or 'Faux'\n    elseif type(v) == 'number' then\n        return tostring(v)\n    else\n        return tostring(v)\n    end\nend\n\nlocal function __psc_write(...)\n    local args = {...}\n    local parts = {}\n    for i = 1, #args do\n        parts[i] = __psc_serialize(args[i])\n    end\n    print(table.concat(parts, ''))\nend\n-- TDA Liste (places enti\u00E8res)\nlocal function __psc_liste_tete(l)\n    return 0\nend\nlocal function __psc_liste_val(l, p)\n    local node = l\n    local i = p or 0\n    while node ~= nil and i > 0 do\n        node = node.suc\n        i = i - 1\n    end\n    return node and node.val or nil\nend\nlocal function __psc_liste_suc(l, p)\n    return (p or 0) + 1\nend\nlocal function __psc_liste_fin(l, p)\n    local node = l\n    local i = p or 0\n    while node ~= nil and i > 0 do\n        node = node.suc\n        i = i - 1\n    end\n    return node == nil\nend\nlocal function __psc_liste_vide()\n    return nil\nend\nlocal function __psc_liste_ajout_tete(l, v)\n    return { val = v, suc = l }\nend\nlocal function __psc_liste_suppression_tete(l)\n    if l == nil then return nil end\n    return l.suc\nend\nlocal function __psc_liste_ajout_queue(l, v)\n    if l == nil then\n        return { val = v, suc = nil }\n    end\n    local head = l\n    local node = l\n    while node.suc ~= nil do\n        node = node.suc\n    end\n    node.suc = { val = v, suc = nil }\n    return head\nend\nlocal function __psc_liste_suppression_queue(l)\n    if l == nil then return nil end\n    if l.suc == nil then return nil end\n    local head = l\n    local prev = nil\n    local node = l\n    while node.suc ~= nil do\n        prev = node\n        node = node.suc\n    end\n    if prev ~= nil then prev.suc = nil end\n    return head\nend\nlocal function __psc_liste_ajout(l, p, v)\n    if l == nil then\n        return { val = v, suc = nil }\n    end\n    local head = l\n    local node = l\n    local i = p or 0\n    while node ~= nil and i > 0 do\n        node = node.suc\n        i = i - 1\n    end\n    if node ~= nil then\n        node.suc = { val = v, suc = node.suc }\n    end\n    return head\nend\nlocal function __psc_liste_suppression(l, p)\n    if l == nil then return nil end\n    local head = l\n    local i = p or 0\n    if i <= 0 then\n        return l.suc\n    end\n    local prev = l\n    local node = l.suc\n    i = i - 1\n    while node ~= nil and i > 0 do\n        prev = node\n        node = node.suc\n        i = i - 1\n    end\n    if node ~= nil then\n        prev.suc = node.suc\n    end\n    return head\nend\nlocal function __psc_liste_change(l, p, v)\n    local node = l\n    local i = p or 0\n    while node ~= nil and i > 0 do\n        node = node.suc\n        i = i - 1\n    end\n    if node ~= nil then\n        node.val = v\n    end\n    return l\nend\n\n-- Construit une liste cha\u00EEn\u00E9e \u00E0 partir d'un tableau Lua s\u00E9quentiel\nlocal function __psc_liste_from_table(t)\n    local l = __psc_liste_vide()\n    if type(t) ~= 'table' then return l end\n    for i = 1, #t do\n        l = __psc_liste_ajout_queue(l, t[i])\n    end\n    return l\nend\n\n-- =================================================================================================================\n-- TDA Pile (Impl\u00E9mentation par table/tableau)\n-- =================================================================================================================\nlocal function __psc_pile_vide()\n    return {_type = 'pile'}\nend\n\nlocal function __psc_pile_sommet(p)\n    if type(p) ~= 'table' or #p == 0 then return nil end\n    return p[#p]\nend\n\nlocal function __psc_pile_est_vide(p)\n    return type(p) ~= 'table' or #p == 0\nend\n\nlocal function __psc_pile_empiler(p, v)\n    if type(p) == 'table' then\n        table.insert(p, v)\n    end\nend\n\nlocal function __psc_pile_depiler(p)\n    if type(p) == 'table' and #p > 0 then\n        table.remove(p)\n    end\nend\n\n-- Cr\u00E9er une pile \u00E0 partir d'un tableau de valeurs\nlocal function __psc_pile_from_values(t)\n    local p = __psc_pile_vide()\n    if type(t) == 'table' then\n        for i = 1, #t do\n            __psc_pile_empiler(p, t[i])\n        end\n    end\n    return p\nend\n\n-- =================================================================================================================\n-- TDA File (Impl\u00E9mentation par table/tableau)\n-- =================================================================================================================\nlocal function __psc_file_vide()\n    return {_type = 'file'}\nend\n\nlocal function __psc_file_est_vide(f)\n    return type(f) ~= 'table' or #f == 0\nend\n\nlocal function __psc_file_enfiler(f, v)\n    if type(f) == 'table' then\n        table.insert(f, v)\n    end\nend\n\nlocal function __psc_file_defiler(f)\n    if type(f) == 'table' and #f > 0 then\n        table.remove(f, 1)\n    end\nend\n\n-- Cr\u00E9er une file \u00E0 partir d'un tableau de valeurs\nlocal function __psc_file_from_values(t)\n    local f = __psc_file_vide()\n    if type(t) == 'table' then\n        for i = 1, #t do\n            __psc_file_enfiler(f, t[i])\n        end\n    end\n    return f\nend\n\n-- Fonction g\u00E9n\u00E9rique pour 'tete' (supporte Liste et File)\nlocal function __psc_generic_tete(obj)\n    if __psc_is_liste(obj) then\n        return __psc_liste_tete(obj)\n    elseif type(obj) == 'table' then\n        -- Pour une file (ou tableau), la t\u00EAte est le premier \u00E9l\u00E9ment\n        return obj[1]\n    end\n    return nil\nend\n\n-- =================================================================================================================\n-- TDA ListeSym (Liste Sym\u00E9trique)\n-- =================================================================================================================\nlocal function __psc_listesym_vide()\n    return { head = nil, tail = nil }\nend\n\nlocal function __psc_listesym_tete(l)\n    return l.head\nend\n\nlocal function __psc_listesym_queue(l)\n    return l.tail\nend\n\nlocal function __psc_listesym_val(l, p)\n    if p then return p.val end\n    return nil\nend\n\nlocal function __psc_listesym_suc(l, p)\n    if p then return p.suc end\n    return nil\nend\n\nlocal function __psc_listesym_prec(l, p)\n    if p then return p.prec end\n    return nil\nend\n\nlocal function __psc_listesym_fin(l, p)\n    return p == nil\nend\n\nlocal function __psc_listesym_ajout_tete(l, v)\n    local new_node = { val = v, suc = l.head, prec = nil }\n    if l.head then\n        l.head.prec = new_node\n    else\n        l.tail = new_node\n    end\n    l.head = new_node\nend\n\nlocal function __psc_listesym_suppression_tete(l)\n    if l.head then\n        l.head = l.head.suc\n        if l.head then\n            l.head.prec = nil\n        else\n            l.tail = nil\n        end\n    end\nend\n\nlocal function __psc_listesym_ajout_queue(l, v)\n    local new_node = { val = v, suc = nil, prec = l.tail }\n    if l.tail then\n        l.tail.suc = new_node\n    else\n        l.head = new_node\n    end\n    l.tail = new_node\nend\n\nlocal function __psc_listesym_suppression_queue(l)\n    if l.tail then\n        l.tail = l.tail.prec\n        if l.tail then\n            l.tail.suc = nil\n        else\n            l.head = nil\n        end\n    end\nend\n\nlocal function __psc_listesym_ajout(l, p, v)\n    if p == nil then\n        __psc_listesym_ajout_queue(l, v)\n    else\n        local new_node = { val = v, suc = p, prec = p.prec }\n        if p.prec then\n            p.prec.suc = new_node\n        else\n            l.head = new_node\n        end\n        p.prec = new_node\n    end\nend\n\nlocal function __psc_listesym_suppression(l, p)\n    if p == nil then return end\n    if p.prec then\n        p.prec.suc = p.suc\n    else\n        l.head = p.suc\n    end\n    if p.suc then\n        p.suc.prec = p.prec\n    else\n        l.tail = p.prec\n    end\nend\n\nlocal function __psc_listesym_change(l, p, v)\n    if p then p.val = v end\nend\n\nlocal function __psc_file_premier(f)\n    if type(f) == 'table' and #f > 0 then\n        return f[1]\n    end\n    return nil\nend\n\n-- Construit une ListeSym \u00E0 partir d'un tableau Lua s\u00E9quentiel\nlocal function __psc_listesym_from_table(t)\n    local l = __psc_listesym_vide()\n    if type(t) ~= 'table' then return l end\n    for i = 1, #t do\n        __psc_listesym_ajout_queue(l, t[i])\n    end\n    return l\nend\n\n-- =================================================================================================================\n-- TDA Table (Dictionnaire/Map: Cl\u00E9 -> Valeur)\n-- =================================================================================================================\nlocal function __psc_table_vide()\n    return {_type = 'table', _data = {}}\nend\n\n-- Retourne l'ensemble des cl\u00E9s (domaine) de la table\nlocal function __psc_table_domaine(t)\n    local keys = {}\n    if type(t) == 'table' and t._data then\n        for k, _ in pairs(t._data) do\n            table.insert(keys, k)\n        end\n    end\n    return keys\nend\n\n-- Acc\u00E8s \u00E0 une valeur par cl\u00E9 (retourne nil si la cl\u00E9 n'existe pas)\nlocal function __psc_table_acces(t, cle)\n    if type(t) == 'table' and t._data then\n        return t._data[cle]\n    end\n    return nil\nend\n\n-- Ajout d'une entr\u00E9e (cl\u00E9, valeur) dans la table\nlocal function __psc_table_ajout(t, cle, valeur)\n    if type(t) == 'table' and t._data then\n        t._data[cle] = valeur\n    end\n    return t\nend\n\n-- Suppression d'une entr\u00E9e de la table\nlocal function __psc_table_suppression(t, cle)\n    if type(t) == 'table' and t._data then\n        t._data[cle] = nil\n    end\n    return t\nend\n\n-- Changement de la valeur associ\u00E9e \u00E0 une cl\u00E9\nlocal function __psc_table_change(t, cle, valeur)\n    if type(t) == 'table' and t._data then\n        t._data[cle] = valeur\n    end\n    return t\nend\n\n-- Fonction utilitaire: v\u00E9rifier si un \u00E9l\u00E9ment est dans un ensemble (table/liste)\nlocal function __psc_ensemble_estdans(ensemble, element)\n    if type(ensemble) == 'table' then\n        for _, v in ipairs(ensemble) do\n            if v == element then\n                return true\n            end\n        end\n    end\n    return false\nend\n\n-- Cr\u00E9er une table \u00E0 partir de paires (cl\u00E9, valeur, cl\u00E9, valeur, ...)\n-- Utilis\u00E9 pour la syntaxe Table(\"Alice\" \u2192 \"1234\", \"Bob\" \u2192 \"5678\")\nlocal function __psc_table_from_pairs(...)\n    local t = __psc_table_vide()\n    local pairs_list = {...}\n    for i = 1, #pairs_list, 2 do\n        local cle = pairs_list[i]\n        local valeur = pairs_list[i + 1]\n        if cle ~= nil and valeur ~= nil then\n            t._data[cle] = valeur\n        end\n    end\n    return t\nend\n\n-- =================================================================================================================\n-- =================================================================================================================\n-- =================================================================================================================\n\n";
